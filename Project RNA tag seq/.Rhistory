# get normalized counts
norm.counts <- assay(dds_norm) %>%
t()
# 4. Network Construction  ---------------------------------------------------
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))
power
# Call the network topology analysis function
sft <- pickSoftThreshold(norm.counts,
powerVector = power,
networkType = "signed",
verbose = 5)
sft.data <- sft$fitIndices
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
geom_hline(yintercept = 0.8, color = 'red') +
labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
theme_classic()
a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
labs(x = 'Power', y = 'Mean Connectivity') +
theme_classic()
grid.arrange(a1, a2, nrow = 2)
# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
soft_power <- 10
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 14000, #suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
traits <- colData %>%
mutate(stress_bin = ifelse(grepl('Stress', group), 1, 0)) %>%
select(9)
# binarize categorical variables
# colData$severity <- factor(colData$severity, levels = c("Healthy", "Convalescent", "ICU", "Moderate", "Severe"))
#
# severity.out <- binarizeCategoricalColumns(colData$severity,
#                                            includePairwise = FALSE,
#                                            includeLevelVsAll = TRUE,
#                                            minCount = 1)
#
#
# traits <- cbind(traits, severity.out)
### NOT DOING ABOVE, NOT RELEVANT
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
View(module.trait.corr.pvals)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[11:11], #trait data
y = names(heatmap.data2)[1:10], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. ARC - WGCNA Module Eigengenes")
grid.arrange(a1, a2, nrow = 2)
soft_power <- 8
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 14000, #suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# grey module = all genes that doesn't fall into other modules were assigned to the grey module
# 6A. Relate modules to traits --------------------------------------------------
# module trait associations
# create traits file - binarize categorical variables
traits <- colData %>%
mutate(stress_bin = ifelse(grepl('Stress', group), 1, 0)) %>%
select(9)
# binarize categorical variables
# colData$severity <- factor(colData$severity, levels = c("Healthy", "Convalescent", "ICU", "Moderate", "Severe"))
#
# severity.out <- binarizeCategoricalColumns(colData$severity,
#                                            includePairwise = FALSE,
#                                            includeLevelVsAll = TRUE,
#                                            minCount = 1)
#
#
# traits <- cbind(traits, severity.out)
### NOT DOING ABOVE, NOT RELEVANT
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
View(module.trait.corr.pvals)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[12:12], #trait data
y = names(heatmap.data2)[1:11], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. ARC - WGCNA Module Eigengenes")
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[13:13], #trait data
y = names(heatmap.data2)[1:12], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. ARC - WGCNA Module Eigengenes")
library(WGCNA)
library(DESeq2)
library(GEOquery)
library(CorLevelPlot)
library(gridExtra)
library(clusterProfiler)
library(enrichplot)
library(biomaRt)
library(AnnotationDbi)
library(annotables)
grcm38 <- grcm38
library(tidyverse)
source("functions/gettop10GO.R")
allowWGCNAThreads()          # allow multi-threading (optional)
data <- read.csv("ham_brain_data/DMH_counts.csv")
phenoData <- read.csv("ham_brain_data/DMH_id.csv")
data[1:10, 1:10]
head(phenoData)
# prepare data
data <- data %>%
gather(key = "samples", value = "counts", -X) %>%
rename(gene = X) %>%
inner_join(., phenoData, by = c("samples" = "X")) %>%
select(1, 3, 4) %>%
spread(key = "subject", value = "counts") %>%
column_to_rownames(var = "gene") %>%
slice(-1:-5)
# 2. QC - outlier detection ------------------------------------------------
# detect outlier genes
gsg <- goodSamplesGenes(t(data))
summary(gsg)
gsg$allOK
table(gsg$goodGenes)
table(gsg$goodSamples)
# remove genes that are detected as outliers
data <- data[gsg$goodGenes == TRUE,]
# detect outlier samples - hierarchical clustering - method 1
htree <- hclust(dist(t(data)), method = "average")
plot(htree)
pca <- prcomp(t(data))
pca.dat <- pca$x
pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)
pca.dat <- as.data.frame(pca.dat)
ggplot(pca.dat, aes(PC1, PC2)) +
geom_point() +
geom_text(label = rownames(pca.dat)) +
labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
y = paste0('PC2: ', pca.var.percent[2], ' %'))
#KM193 again seems like a potential outlier, maybe a little KM197, but less than htree.  - generally tighter tho, so keeping them all.
# exclude outlier samples
samples.to.be.excluded <- c("KM193","KM194","KM197")
data.subset <- data[,!(colnames(data) %in% samples.to.be.excluded)]
phenoData <- phenoData %>%
column_to_rownames(var = "subject")
# exclude outlier samples
colData <- phenoData %>%
filter(!row.names(.) %in% samples.to.be.excluded)
# fixing column names in colData
names(colData)
# selecting relevant info
colData <- colData %>%
select(3, 10, 11, 13, 14, 15, 20, 22)
# making the rownames and column names identical
all(rownames(colData) %in% colnames(data.subset))
all(rownames(colData) == colnames(data.subset))
# create dds
dds <- DESeqDataSetFromMatrix(countData = data.subset,
colData = colData,
design = ~ 1) # not specifying model "because we need this DSeq data set to perform variance stabilizing transformation"
dds75 <- dds[rowSums(counts(dds) >= 15) >= 15,]
nrow(dds75) # 9241 genes
# perform variance stabilization
dds_norm <- vst(dds75)
# get normalized counts
norm.counts <- assay(dds_norm) %>%
t()
# 4. Network Construction  ---------------------------------------------------
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))
power
# Call the network topology analysis function
sft <- pickSoftThreshold(norm.counts,
powerVector = power,
networkType = "signed",
verbose = 5)
sft.data <- sft$fitIndices
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
geom_hline(yintercept = 0.8, color = 'red') +
labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
theme_classic()
a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
labs(x = 'Power', y = 'Mean Connectivity') +
theme_classic()
grid.arrange(a1, a2, nrow = 2)
# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
soft_power <- 9  ### SELECTED BY ABOVE
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 14000, #suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# create traits file - binarize categorical variables
traits <- colData %>%
mutate(stress_bin = ifelse(grepl('Stress', group), 1, 0)) %>%
select(9)
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
View(module.trait.corr.pvals)
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
names(heatmap.data2)
View(heatmap.data2)
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[44:44], #trait data
y = names(heatmap.data2)[1:43], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. DMH - WGCNA Module Eigengenes")
soft_power <- 10  ### SELECTED BY ABOVE
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 14000, #suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# grey module = all genes that doesn't fall into other modules were assigned to the grey module
# 6A. Relate modules to traits --------------------------------------------------
# module trait associations
# create traits file - binarize categorical variables
traits <- colData %>%
mutate(stress_bin = ifelse(grepl('Stress', group), 1, 0)) %>%
select(9)
# binarize categorical variables
# colData$severity <- factor(colData$severity, levels = c("Healthy", "Convalescent", "ICU", "Moderate", "Severe"))
#
# severity.out <- binarizeCategoricalColumns(colData$severity,
#                                            includePairwise = FALSE,
#                                            includeLevelVsAll = TRUE,
#                                            minCount = 1)
#
#
# traits <- cbind(traits, severity.out)
### NOT DOING ABOVE, NOT RELEVANT
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
View(module.trait.corr.pvals)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
names(heatmap.data2)
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[32:32], #trait data
y = names(heatmap.data2)[1:31], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. DMH - WGCNA Module Eigengenes")
soft_power <- 12  ### SELECTED BY ABOVE
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 14000, #suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# create traits file - binarize categorical variables
traits <- colData %>%
mutate(stress_bin = ifelse(grepl('Stress', group), 1, 0)) %>%
select(9)
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
View(module.trait.corr.pvals)
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
names(heatmap.data2)
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in stressed
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[18:18], #trait data
y = names(heatmap.data2)[1:17], #ME data
col = c("blue3", "skyblue", "white", "#f7ab5e", "orange2"),
main = "A. DMH - WGCNA Module Eigengenes")
grid.arrange(a1, a2, nrow = 2)
